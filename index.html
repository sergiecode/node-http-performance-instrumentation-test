<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Node HTTP Performance Instrumentation</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <header>
    <h1>ğŸš€ Node HTTP Performance Instrumentation</h1>
    <p class="subtitle">VisualizaciÃ³n de mÃ©tricas HTTP reales obtenidas desde el runtime de Node.js</p>
  </header>

  <main>
    <section class="info-box">
      <h2>ğŸ“‹ Principio ArquitectÃ³nico</h2>
      <p><strong>La red se mide en Node.js, no en el browser.</strong></p>
      <p>Este proyecto es un laboratorio tÃ©cnico para explorar, entender y visualizar mÃ©tricas HTTP reales.</p>
    </section>

    <section class="controls">
      <button id="runTest" class="btn-primary">â–¶ï¸ Ejecutar Test HTTP</button>
      <button id="clearResults" class="btn-secondary">ğŸ—‘ï¸ Limpiar Resultados</button>
    </section>

    <section id="status" class="status-box" style="display: none;">
      <p class="status-message"></p>
    </section>

    <section id="metrics-container">
      <h2>ğŸ“Š MÃ©tricas Instrumentadas</h2>
      <div id="metrics" class="metrics-grid">
        <p class="empty-state">ğŸ‘† Haz clic en "Ejecutar Test HTTP" para ver las mÃ©tricas</p>
      </div>
    </section>

    <section class="legend">
      <h3>ğŸ”‘ Leyenda de Propiedades</h3>
      <div class="legend-grid">
        <div class="legend-item">
          <strong>_startTime</strong>
          <span>Inicio total end-to-end</span>
        </div>
        <div class="legend-item">
          <strong>_requestStart</strong>
          <span>EnvÃ­o del request</span>
        </div>
        <div class="legend-item">
          <strong>_responseStart</strong>
          <span>Primer byte (TTFB)</span>
        </div>
        <div class="legend-item">
          <strong>_responseEnd</strong>
          <span>Fin de descarga</span>
        </div>
        <div class="legend-item">
          <strong>_domainLookupStart</strong>
          <span>Inicio DNS</span>
        </div>
        <div class="legend-item">
          <strong>_domainLookupEnd</strong>
          <span>Fin DNS</span>
        </div>
        <div class="legend-item">
          <strong>duration</strong>
          <span>DuraciÃ³n total (ms)</span>
        </div>
        <div class="legend-item">
          <strong>timeToFirstByte</strong>
          <span>TTFB (ms)</span>
        </div>
      </div>
    </section>
  </main>

  <footer>
    <p>
      Este repositorio es una <strong>referencia tÃ©cnica</strong> para instrumentaciÃ³n HTTP en Node.js.
      No utiliza Performance Observer API. Las mÃ©tricas provienen del runtime real de Node.js.
    </p>
  </footer>

  <script>
    // Funciones de renderizado (integradas desde renderer.js)
    function renderMetrics(data, containerId = 'metrics') {
      const container = document.getElementById(containerId);
      
      if (!container) {
        console.error(`Container with id "${containerId}" not found`);
        return;
      }

      container.innerHTML = '';
      const sections = categorizeMetrics(data);

      Object.entries(sections).forEach(([sectionName, properties]) => {
        const section = createSection(sectionName, properties);
        container.appendChild(section);
      });
    }

    function categorizeMetrics(data) {
      const sections = {
        'IdentificaciÃ³n': {},
        'Timestamps (microsegundos)': {},
        'TamaÃ±os (bytes)': {},
        'HTTP y Backend': {},
        'MÃ©tricas Calculadas': {},
        'Estado': {}
      };

      Object.entries(data).forEach(([key, value]) => {
        if (key === '_iterationNumber' || key === '_threadNumber') {
          sections['IdentificaciÃ³n'][key] = value;
        } else if (key.includes('Time') || key.includes('Start') || key.includes('End')) {
          sections['Timestamps (microsegundos)'][key] = value;
        } else if (key.includes('Size')) {
          sections['TamaÃ±os (bytes)'][key] = value;
        } else if (key.startsWith('_http') || key === '_podInstance' || key === '_profiling' || key === '_resultPayload') {
          sections['HTTP y Backend'][key] = value;
        } else if (key.startsWith('is') || key === 'confidenceRange') {
          sections['Estado'][key] = value;
        } else {
          sections['MÃ©tricas Calculadas'][key] = value;
        }
      });

      return sections;
    }

    function createSection(title, properties) {
      const section = document.createElement('div');
      section.className = 'metric-section';

      const heading = document.createElement('h2');
      heading.textContent = title;
      section.appendChild(heading);

      Object.entries(properties).forEach(([key, value]) => {
        const row = createPropertyRow(key, value);
        section.appendChild(row);
      });

      return section;
    }

    function createPropertyRow(key, value) {
      const row = document.createElement('div');
      row.className = 'metric-row';

      const keySpan = document.createElement('span');
      keySpan.className = 'metric-key';
      keySpan.textContent = key;

      const valueSpan = document.createElement('span');
      valueSpan.className = 'metric-value';
      valueSpan.textContent = formatValue(key, value);

      row.appendChild(keySpan);
      row.appendChild(valueSpan);

      return row;
    }

    function formatValue(key, value) {
      if (key === '_resultPayload' && typeof value === 'string' && value.length > 100) {
        return value.substring(0, 100) + '...';
      }

      if (key === '_httpHeaders' && typeof value === 'string' && value.length > 150) {
        return value.substring(0, 150) + '...';
      }

      if (typeof value === 'number' && !Number.isInteger(value)) {
        return value.toFixed(2);
      }

      if (typeof value === 'boolean') {
        return value ? 'âœ… true' : 'âŒ false';
      }

      if (value === null || value === undefined) {
        return 'null';
      }

      return JSON.stringify(value);
    }

    function renderError(error, containerId = 'metrics') {
      const container = document.getElementById(containerId);
      
      if (!container) return;

      container.innerHTML = `
        <div class="error-message">
          <h2>âŒ Error</h2>
          <p>${error.message || error}</p>
        </div>
      `;
    }

    // LÃ³gica principal de la aplicaciÃ³n
    const runTestBtn = document.getElementById('runTest');
    const clearResultsBtn = document.getElementById('clearResults');
    const statusBox = document.getElementById('status');
    const statusMessage = document.querySelector('.status-message');
    const metricsContainer = document.getElementById('metrics');

    async function runHTTPTest() {
      showStatus('â³ Ejecutando request HTTP instrumentada...', 'loading');

      try {
        const mockData = {
          _iterationNumber: 1,
          _threadNumber: 0,
          _startTime: Date.now() * 1000,
          _requestStart: Date.now() * 1000 + 5000,
          _responseStart: Date.now() * 1000 + 85000,
          _responseEnd: Date.now() * 1000 + 125000,
          _endTime: Date.now() * 1000 + 130000,
          _domainLookupStart: Date.now() * 1000 + 2000,
          _domainLookupEnd: Date.now() * 1000 + 4500,
          _httpStatus: 200,
          _httpHeaders: JSON.stringify({ 'content-type': 'application/json', 'content-length': '292' }),
          _resultPayload: JSON.stringify({ userId: 1, id: 1, title: 'sunt aut facere repellat provident' }),
          _podInstance: null,
          _profiling: null,
          _requestSize: 0,
          _responseSize: 292,
          _transferSize: 292,
          duration: 125.45,
          totalResponseTime: 120.33,
          dnsLookupTime: 2.50,
          serverProcessingTime: 77.83,
          timeToFirstByte: 80.33,
          downloadTime: 40.00,
          isSuccess: true,
          isLocalCached: false,
          isBackendCached: false,
          confidenceRange: 'WITHIN_SLA'
        };

        await new Promise(resolve => setTimeout(resolve, 1000));

        renderMetrics(mockData, 'metrics');
        showStatus('âœ… Test completado correctamente', 'success');

        setTimeout(() => hideStatus(), 3000);

      } catch (error) {
        renderError(error, 'metrics');
        showStatus('âŒ Error durante la ejecuciÃ³n', 'error');
      }
    }

    function clearResults() {
      metricsContainer.innerHTML = '<p class="empty-state">ğŸ‘† Haz clic en "Ejecutar Test HTTP" para ver las mÃ©tricas</p>';
      hideStatus();
    }

    function showStatus(message, type) {
      statusMessage.textContent = message;
      statusBox.className = `status-box ${type}`;
      statusBox.style.display = 'block';
    }

    function hideStatus() {
      statusBox.style.display = 'none';
    }

    runTestBtn.addEventListener('click', runHTTPTest);
    clearResultsBtn.addEventListener('click', clearResults);
  </script>
</body>
</html>
